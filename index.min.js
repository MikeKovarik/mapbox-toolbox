(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define('mapbox-toolbar', ['exports'], factory) :
	(global = global || self, factory(global['mapbox-toolbar'] = {}));
}(this, function (exports) { 'use strict';

	var {Evented} = mapboxgl;
	Evented.prototype.emit = Evented.prototype.fire;
	Evented.prototype.removeAllListeners = function() {
		for (let [name, listeners] of Object.entries(options._listeners))
			for (let listener of listeners)
				this.off(name, listener);
	};
	var EventEmitter = Evented;

	var featuresMap = new WeakMap;

	function isGeoJson(arg) {
		return arg
			&& arg.type
			&& ((arg.geometry && arg.geometry.type && arg.geometry.coordinates) || arg.features)
	}

	function isCoord(arg) {
		return Array.isArray(arg)
			&& arg.length === 2
			&& typeof arg[0] === 'number'
			&& typeof arg[1] === 'number'
	}

	function isCoords(arg) {
		return Array.isArray(arg)
			&& isCoord(arg[0])
	}

	function isBbox(arg) {
		return Array.isArray(arg)
			&& (isFlatBbox(arg) || isNestedBbox(arg))
	}

	function isFlatBbox(arr) {
		return arr.length === 4
			&& typeof arr[0] === 'number'
	}

	function isNestedBbox(arr) {
		return arr.length === 2
			&& arr[0].length === 2
			&& arr[1].length === 2
			//&& typeof arr[0] === 'number'
	}

	function createRandomId() {
		return String(new Date().getTime()) + Math.random().toString().slice(2)
	}


	// paint['line-dasharray'] = [2, 1]
	const SOLID = undefined;
	//export const DOTTED = [1, 1]
	const DOTTED = [0.8, 0.8];
	const DASHED = [2, 1];

	function getStyle(arg) {
		switch (arg) {
			case 'dashed': return DASHED
			case 'dotted': return DOTTED
			default:       return arg
		}
	}

	function extend(Target, Source) {
		var staticDesc = Object.getOwnPropertyDescriptors(Source);
		delete staticDesc.name;
		delete staticDesc.length;
		delete staticDesc.prototype;
		var protoDesc = Object.getOwnPropertyDescriptors(Source.prototype);
		delete protoDesc.constructor;
		Object.defineProperties(Target, staticDesc);
		Object.defineProperties(Target.prototype, protoDesc);
	}


	function createGetters(Class) {
		//var descriptors = Object.getOwnPropertyDescriptors(Class.prototype)
		var descriptors = {};
		if (Class.paint) {
			Class.paintKeys = Class.paint.map(sliceFirstSection);
			Class.paint.forEach((prop, index) => {
				let key = Class.paintKeys[index];
				descriptors[key] = {
					get() {return this.layer.getPaintProperty(prop)},
					set(value) {this.map.setPaintProperty(this.id, prop, value);}
				};
			});
		}
		if (Class.layout) {
			Class.layoutKeys = Class.layout.map(sliceFirstSection);
			Class.layout.forEach((prop, index) => {
				let key = Class.layoutKeys[index];
				descriptors[key] = {
					get() {return this.layer.getLayoutProperty(prop)},
					set(value) {this.map.setLayoutProperty(this.id, prop, value);}
				};
			});
		}
		Object.defineProperties(Class.prototype, descriptors);
	}

	function sliceFirstSection(prop) {
		return prop.slice(prop.indexOf('-') + 1)
	}

	class MapExtension {

		addGeoJson(data) {
			var id = createRandomId();
			this.addSource(id, {type: 'geojson', data});
			return this.getSource(id)
		}

		get allLayers() {
			var styleObject = this.getStyle();
			return styleObject && styleObject.layers || []
		}

		get layers() {
			return this.allLayers
				.filter(l => l.source !== 'composite')
				.filter(l => l.type !== 'background')
				.map(l => this.getLayer(l.id))
		}

		get allSources() {
			return Object.keys(this.getStyle().sources)
				.map(id => this.getSource(id))
		}

		get sources() {
			return this.allSources
				.filter(feature => feature.id !== 'composite')
		}

		get renderedFeatures() {
			var ids = [];
			var options = {
				layers: this.layers.map(l => l.id)
			};
			return this.queryRenderedFeatures(options)
				//.filter(fd => fd.source !== 'composite')
				.filter(fd => {
					var {id} = fd.properties;
					if (!ids.includes(id)) {
						ids.push(id);
						return true
					}
					return false
				})
				.map(fd => {
					var {id} = fd.properties;
					var source = map.getSource(fd.source);
					return source._data.features.find(f => f.properties.id === id)
				})
		}

		get renderedSources() {
			var ids = this.renderedFeatures.map(feature => feature.source);
			ids = [...new Set(ids)];
			return ids.map(id => this.getSource(id))
		}

		get lines() {
			return this.features.filter(feature => feature.constructor.name === 'Line')
		}

		get points() {
			return this.features.filter(feature => feature.constructor.name === 'Point')
		}

		get cursor() {return this.canvas.style.cursor}
		set cursor(cursor) {this.canvas.style.cursor = cursor;}

		get zoom() {return this.getZoom()}
		set zoom(zoom) {this.easeTo({zoom});}

		get bearing() {return this.getBearing()}
		set bearing(bearing) {this.easeTo({bearing});}

		get pitch() {return this.getPitch()}
		set pitch(pitch) {this.easeTo({pitch});}

		get rotation() {return this.bearing}
		set rotation(bearing) {this.bearing = bearing;}

		get tilt() {return this.pitch}
		set tilt(pitch) {this.pitch = pitch;}

		get center() {return this.getCenter().toArray()}
		set center(center) {this.flyTo({center});}

		get bounds() {return this.getBounds().toArray().flat()}
		set bounds(bounds) {
			console.warn('not implemented');
		}
		get bbox() {return this.bounds}
		set bbox(bbox) {this.bounds = bbox;}

		get canvas() {
			if (this.__canvas) return this.__canvas
			return this.__canvas = this.getCanvas()
		}

	}

	extend(mapboxgl.Map, MapExtension);

	var {Map} = mapboxgl;

	var _easeTo = Map.prototype.easeTo;
	var _panTo = Map.prototype.panTo;
	var _fitBounds = Map.prototype.fitBounds;

	class MapExtension$1 {

		// TODO: get/set current center. alternative for get center() {}
		//get lon() {}
		//get lng() {}
		//get lat() {}

		get width()  {return this.transform.width}
		get height() {return this.transform.height}

		get effectiveWidth()  {return this.width  - this.offset.left - this.offset.right}
		get effectiveHeight() {return this.height - this.offset.top  - this.offset.bottom}

		get computedPadding() {
			let {offset, padding} = this;
			return {
				top:    offset.top    + padding.top,
				right:  offset.right  + padding.right,
				bottom: offset.bottom + padding.bottom,
				left:   offset.left   + padding.left,
			}
		}

		get computedOffset() {
			let {offset} = this;
			return [
				(offset.left - offset.right) / 2,
				(offset.top - offset.bottom) / 2
			]
		}

		get padding() {
			if (this._padding) return this._padding
			var horizontal = this.width  / 14;
			var vertical   = this.height / 14;
			return {
				top: vertical,
				right: horizontal,
				bottom: vertical,
				left: horizontal
			}
		}
		set padding(padding) {
			this._padding = padding;
		}

		get offset() {
			return Object.assign({top: 0, right: 0, bottom: 0, left: 0}, this._offset)
		}
		set offset(offset) {
			this._offset = offset;
		}

		// TODO: remove geojson support, keep as close to original API as possible
		panTo(center, options = {}, e) {
			if (isGeoJson(center))
				center = center.geometry.coordinates;
			if (typeof options === 'number')
				options = {duration: options};
			return _panTo.call(this, center, options, e)
		}

		// TODO: remove geojson support, keep as close to original API as possible
		// only keep padding/offset support
		easeTo(options, e) {
			if (isGeoJson(options.center))
				options.center = options.center.geometry.coordinates;
			if (options.offset === undefined)
				options.offset = this.computedOffset;
			return _easeTo.call(this, options, e)
		}

		// TODO: remove geojson support, keep as close to original API as possible
		// only keep padding/offset support
		fitBounds(bounds, options = {}, e) {
			if (isGeoJson(bounds)) {
				let coords = bounds.geometry.coordinates;
				bounds = new mapboxgl.LngLatBounds(coords[0], coords[0]);
				coords.reduce((bounds, coord) => bounds.extend(coord), bounds);
			}
			if (options.padding === undefined)
				options.padding = this.computedPadding;
			return _fitBounds.call(this, bounds, options, e)
		}


		// TODO: rework to use custom methods instead of modifying original API
		animateTo(coords) {
			if (isGeoJson(coords)) {
				if (coords.geometry.type === 'Point')
					return this.easeTo({center: coords})
				else
					return this.fitBounds(coords)
			} else if (isCoord(coords)) {
				return this.easeTo({center: coords})
			} else if (isBbox(coords)) {
				return this.fitBounds(coords)
			}
		}


		// TODO: polish these custom methods

		_transformArgsToMapOptions(args) {
			var [mapOptions, arg] = args.reverse();
			if (Array.isArray(mapOptions)) {
				arg = mapOptions;
				mapOptions = {};
			}
			if (arg) {
				if (isBbox(arg))
					mapOptions.bounds = arg;
				else if (isCoord(arg))
					mapOptions.center = arg;
			}
			return mapOptions
		}

		jump(...args) {
			var mapOptions = this._transformArgsToMapOptions(args);
			if (mapOptions.bounds) {
				var bounds = mapOptions.bounds;
				delete mapOptions.bounds;
				mapOptions.duration = 0;
				this.fitBounds(bounds, mapOptions);
			} else {
				this.jumpTo(mapOptions);
			}
		}

		animate(...args) {
			var mapOptions = this._transformArgsToMapOptions(args);
			if (mapOptions.duration === undefined) {
				var distance = 3; // TODO
				var baseDuration = 200;
				mapOptions.duration = baseDuration * distance;
			}
			if (mapOptions.bounds) {
				var bounds = mapOptions.bounds;
				delete mapOptions.bounds;
				this.fitBounds(bounds, mapOptions);
			} else {
				this.easeTo(mapOptions);
			}
			return Promise.timeout(mapOptions.duration)
		}

	}

	extend(Map, MapExtension$1);

	function isSource(obj) {
		return obj
			&& obj.id
			&& obj.type === 'geojson'
	}

	class CompoundItem extends EventEmitter {
		
		// cached values like bbox. resets by updating coords and data
		_cached = {}

		constructor(args) {
			super();

			this.id = createRandomId();

			if (isSource(args[0]))
				this.source = args.shift();
			if (isGeoJson(args[0]))
				this._createSourceOptions(args.shift());
			else if (Array.isArray(args[0]))
				this._createSourceOptions(this._ensureGeoJson(args.shift()));
			else
				this._createSourceOptions(this._createDummy());

			this.options = {paint: {}, layout: {}};
			if (typeof args[args.length - 1] === 'object')
				this._handleOptionsObject(args.pop());
			if (this._createOptionsFromArgs && args.length > 0)
				this._handleOptionsObject(this._createOptionsFromArgs(...args));

			this.onPointDragStart = this.onPointDragStart.bind(this);
			this.onPointDragMove = this.onPointDragMove.bind(this);
			this.onPointDragEnd = this.onPointDragEnd.bind(this);
		}

		_createSourceOptions(data) {
			this.sourceOptions = {data, type: 'geojson'};
		}

		// TODO: merge with _ensureLayerOptions
		_handleOptionsObject(object) {
			if (object.paint || object.layout)
				Object.assign(this.options, object);
			else
				this._parseOptionsObject(object);
		}

		_parseOptionsObject(object) {
			let Class = this.constructor;
			let {paintKeys, layoutKeys} = Class;
			let paintProps = Class.paint;
			let layoutProps = Class.layout;
			for (let [prop, value] of Object.entries(object)) {
				if (value === undefined) continue
				if (paintProps) {
					if (paintProps.includes(prop)) {
						this.options.paint[prop] = value;
					} else if (paintKeys.includes(prop)) {
						let index = paintKeys.indexOf(prop);
						prop = paintProps[index];
						this.options.paint[prop] = value;
					}
				}
				if (layoutProps) {
					if (layoutProps.includes(prop)) {
						this.options.layout[prop] = value;
					} else if (layoutKeys.includes(prop)) {
						let index = layoutKeys.indexOf(prop);
						prop = layoutProps[index];
						this.options.layout[prop] = value;
					}
				}
			}
		}

		// NOTE: this is not part of constructor, because we're tapping into instance
		// properties created by classes inheriting from this one. Their data is not
		// available to use here during instationation.
		_ensureLayerOptions() {
			if (this.optionsReady) return
			this.optionsReady = true;

			var Class = this.constructor;
			var paintProps  = Class.paint  || [];
			var layoutProps = Class.layout || [];

			this.layerOptions = Object.assign(this.layerOptions || {}, {
				id: this.id,
				source: this.id,
				type: Class.type,
			});

			this.layerOptions.layout = Object.assign({}, this.layout, this.layerOptions.layout, this.options.layout);
			this.layerOptions.paint  = Object.assign({}, this.paint,  this.layerOptions.paint,  this.options.paint);

			for (let [key, value] of Object.entries(this.options)) {
				// transform current value
				if (value === undefined || value === null) continue
				if (layoutProps[key]) {
					var prop = layoutProps[key];
					this.layerOptions.layout[prop] = value;
				} else if (paintProps[key]) {
					var prop = paintProps[key];
					this.layerOptions.paint[prop] = value;
				}
			}

			if (this._processOptions)
				this._processOptions();
		}

		addTo(map) {
			this._ensureLayerOptions();

			this.map = map;

			if (this.source) {
				this.layerOptions.source = this.source.id;
			} else {
				this.map.addSource(this.id, this.sourceOptions);
				this.source = this.map.getSource(this.id);
			}

			this.map.addLayer(this.layerOptions);
			this.layer = this.map.getLayer(this.id);

			//featuresMap.set(this.source, this)
			featuresMap.set(this.layer, this);

			return this
		}

		render(data = this.data) {
			this.data = data;
		}

		update() {
			this.render();
		}

		remove() {
			this.map.removeLayer(this.id);
			this.map.removeSource(this.id);
			this.draggable = false;
		}

		async fadeIn(duration = 240) {
			var opacityProp = this.constructor.paint.opacity;
			var transitionProp = opacityProp + '-transition';
			this.map.setPaintProperty(this.id, transitionProp, {duration: 0});
			this.map.setPaintProperty(this.id, opacityProp, 0);
			await Promise.timeout();
			this.map.setPaintProperty(this.id, transitionProp, {duration});
			this.map.setPaintProperty(this.id, opacityProp, 1);
			return Promise.timeout(duration)
		}

		async fadeOut(duration = 240) {
			var opacityProp = this.constructor.paint.opacity;
			var transitionProp = opacityProp + '-transition';
			this.map.setPaintProperty(this.id, transitionProp, {duration: 0});
			this.map.setPaintProperty(this.id, opacityProp, 1);
			await Promise.timeout();
			this.map.setPaintProperty(this.id, transitionProp, {duration});
			this.map.setPaintProperty(this.id, opacityProp, 0);
			return Promise.timeout(duration)
		}

		// GEOJSON mimic

		get properties() {
			return this.data.properties
		}
		set properties(newData) {
			this.data.properties = newData;
		}

		get geometry() {
			return this.data.geometry
		}
		set geometry(newData) {
			this.data.geometry = newData;
			this.render();
		}

		toJSON() {
			return JSON.stringify(this.data)
		}

		// GEOJSON sugar

		_ensureGeoJson(data) {
			if (isGeoJson(data)) return data
			return this._wrapInGeoJson(data)
		}

		get data() {
			return this.source._data
			//return this.data.source.serialize()
		}
		set data(data) {
			this._cached = {};
			if (!data)
				data = this._createDummy();
			else
				data = this._ensureGeoJson(data);
			this.source.setData(data);
		}

		get coords() {
			return this.data
				&& this.data.geometry
				&& this.data.geometry.coordinates
		}
		set coords(coords) {
			this._cached = {};
			if (!coords) {
				this.data = undefined;
			} else if (this.empty) {
				this.data = this._wrapInGeoJson(coords);
			} else {
				this.data.geometry.coordinates = coords;
				this.render();
			}
		}

		get empty() {
			let data = this.data;
			if (!data) return true
			if (data.geometry && data.geometry.coordinates)
				return data.geometry.coordinates.length === 0
			if (data.features)
				return data.features.length === 0
			return false
		}

		// VISIBILITY

		// map.isHidden()

		get visible() {
			return this.layer.getLayoutProperty('visibility') === 'visible'
		}
		set visible(value) {
			if (value === true) value = 'visible';
			if (value === false) value = 'none';
			return this.map.setLayoutProperty(this.id, 'visibility', value)
		}

		get hidden() {return !this.visible}
		set hidden(value) {this.visible = !value;}

		show() {
			this.visible = true;
		}

		hide() {
			this.visible = false;
		}

		// EVENTS ////////////////////////////////////////

		// We want simple mouse/touch event to propagate down to our component
		// but keep the custom events created locally away from mixing up with
		// similarly names events from the map.
		localEvents = ['dragstart', 'drag', 'dragend']

		on(name, handler) {
			if (this.localEvents.includes(name))
				this._on(name, handler);
			else
				return this.map.on(name, this.id, handler)
		}
		off(name, handler) {
			if (this.localEvents.includes(name))
				this._off(name, handler);
			else
				return this.map.off(name, this.id, handler)
		}
		once(name, handler) {
			if (this.localEvents.includes(name))
				this._once(name, handler);
			else
				return this.map.once(name, this.id, handler)
		}

		// DRAGGABLE ////////////////////////////////////////

		get draggable() {
			return !!this._draggable
		}
		set draggable(value) {
			if (this._draggable === value) return
			this._draggable = value;
			if (value) {
				this.map.on('mousedown',  this.id, this.onPointDragStart);
				this.map.on('touchstart', this.id, this.onPointDragStart);
			} else {
				this.map.off('mousedown',  this.id, this.onPointDragStart);
				this.map.off('touchstart', this.id, this.onPointDragStart);
			}
		}

		onPointDragStart(e) {
			// giving time to pointer and other more important touchpoints to react to the event
			//await Promise.timeout()
			if (e.defaultPrevented) return
			// Pinch to zoom gets caught by the touch events of the line sometimes, even though both touch points are outside of the line.
			// Ignore these multipoint events. 'points' property only appears on touch* events, not on mouse* events.
			if (e.points && e.points.length > 1) return
			e.preventDefault();
			this.map.on('mousemove', this.onPointDragMove);
			this.map.on('touchmove', this.onPointDragMove);
			this.map.once('mouseup', this.onPointDragEnd);
			this.map.once('touchend', this.onPointDragEnd);
			this.emit('dragstart', createEventData(e));
		}

		onPointDragMove(e) {
			e.preventDefault();
			this.emit('drag', createEventData(e));
		}

		onPointDragEnd(e) {
			e.preventDefault();
			this.map.off('mousemove', this.onPointDragMove);
			this.map.off('touchmove', this.onPointDragMove);
			this.map.off('mouseup', this.onPointDragEnd);
			this.map.off('touchend', this.onPointDragEnd);
			this.emit('dragend', createEventData(e));
		}
	/*
		get source() {
			return this._source
		}

		set source(newSource) {
			if (typeof newSource === 'string')
				this._source = this.map.getSource(newSource)
			else
				this._source = newSource
		}

		changeSource(layerId, source, sourceLayer) {
			const oldLayers = map.getStyle().layers
			const layerIndex = oldLayers.findIndex(l => l.id === layerId)
			const layerDef = oldLayers[layerIndex]
			const before = oldLayers[layerIndex + 1] && oldLayers[layerIndex + 1].id
			layerDef.source = source
			if (sourceLayer)
				layerDef['source-layer'] = sourceLayer
			map.removeLayer(layerId)
			map.addLayer(layerDef, before)
		}
	*/
	}

	function createEventData(e) {
		return {
			lngLat: e.lngLat,
			coords: e.lngLat.toArray(),
		}
	}

	CompoundItem.prototype._on   = EventEmitter.prototype.on;
	CompoundItem.prototype._off  = EventEmitter.prototype.off;
	CompoundItem.prototype._once = EventEmitter.prototype.once;

	/*
	export const POINT_PAINT = {
		"circle-radius": {
			stops: [
				[3, 3],
				[8, 5]
			]
		},
		"circle-color": "#fff",
		"circle-stroke-color": "#fff",
		"circle-stroke-width": {
			stops: [
				[5, 5],
				[9, 5]
			]
		},
		"circle-stroke-opacity": .2
	}
	*/
	class Point extends CompoundItem {

		static type = 'circle'

		static paint = [
			'circle-radius',
			'circle-color',
			'circle-opacity',
			'circle-stroke-width',
			'circle-stroke-color',
			'circle-stroke-opacity',
		]

		paint = {
			'circle-radius': 8,
		}

		get size() {
			return this['circle-radius']
		}
		set size(value) {
			this['circle-radius'] = value;
		}

		_wrapInGeoJson(coords) {
			return turf.point(coords)
		}

		_createDummy() {
			return turf.point([])
		}

		_createOptionsFromArgs(...args) {
			var options = {};
			for (let arg of args) {
				switch (typeof arg) {
					case 'string':
						options.color = arg;
						break
					case 'number':
						options.radius = arg;
						break
				}
			}
			return options
		}

		setLngLat(coords) {
			this.data.geometry.coordinates = coords;
			this.update();
			return this
		}

	}

	createGetters(Point);

	const LAYOUT = {
		'line-cap': 'round',
		'line-join': 'round'
	};

	const VARIABLE_WIDTH = [
		'interpolate', ['linear'], ['zoom'],
		4, 0.4,
		15, 4,
		20, 10,
	];

	class Line extends CompoundItem {

		static type = 'line'

		static paint = [
			'line-width',
			'line-color',
			'line-opacity',
		]

		static layout = [
			'line-cap',
			'line-join',
			'line-dasharray'
		]

		paint = {
			'line-width': VARIABLE_WIDTH,
		}

		_wrapInGeoJson(coords) {
			return turf.lineString(coords)
		}

		_createDummy() {
			return {type: 'FeatureCollection', features: []}
		}

		_createOptionsFromArgs(color, size, style) {
			return {color, size, style}
		}

		_processOptions() {
			if (this.options.style) {
				this.layerOptions.paint['line-dasharray'] = getStyle(this.options.style);
			} else {
				this.layerOptions.layout = LAYOUT;
			}
		}

		get length() {
			return turf.length(this.data)
		}

		get gradient() {
			return this.layer.getPaintProperty('line-gradient')
		}
		set gradient(stops) {
			if (Array.isArray(stops)) {
				let gradient = [
					'interpolate',
					['linear'],
					['line-progress'],
					...stops
				];
				this.map.setPaintProperty(this.id, 'line-gradient', gradient);
			} else {
				// TODO
			}
			var opts = this.source.workerOptions.geojsonVtOptions;
			if (!opts.lineMetrics) {
				opts.lineMetrics = true;
				this.render();
			}
		}

		get bbox() {
			if (this._cached.bbox) return this._cached.bbox
			return this._cached.bbox = turf.bbox(this.data)
		}

		get square() {
			if (this._cached.square) return this._cached.square
			return this._cached.square = turf.square(this.bbox)
		}

		get renderedSize() {
			var bbox = this.bbox;
			var leftTop     = this.map.project([bbox[0], bbox[1]]);
			var bottomRight = this.map.project([bbox[2], bbox[3]]);
			var width  = Math.abs(bottomRight.x - leftTop.x);
			var height = Math.abs(bottomRight.y - leftTop.y);
			return {width, height}
		}

		get visibleRatios() {
			var size = this.renderedSize;
			var width  = size.width  / this.map.effectiveWidth;
			var height = size.height / this.map.effectiveHeight;
			return {width, height}
		}

		get visibleRatio() {
			var {width, height} = this.visibleRatios;
			return Math.max(width, height)
		}

	}

	createGetters(Line);

	class Polygon extends CompoundItem {

		static type = 'fill'

		static paint = [
			'fill-color',
			'fill-opacity',
		]

		paint = {
			'fill-opacity': 0.1,
		}

		_wrapInGeoJson(arg) {
			if (Array.isArray(arg)) {
				if (arg.length === 4 && typeof arg[0] === 'number')
					return turf.bboxPolygon(arg)
				else
					return turf.polygon(arg)
			}
			console.warn('unknown polygon data');
		}

		_createDummy() {
			return turf.polygon([])
		}

		_createOptionsFromArgs(color, opacity) {
			return {color, opacity}
		}

		get opacity() {
			return this.layer.paint['fill-opacity']
		}

		set opacity(value) {
			this.layer.paint['fill-opacity'] = value;
			this.render();
		}

	}

	createGetters(Polygon);

	class Label extends CompoundItem {

		static type = 'symbol'

		static layout = [
			'symbol-placement',
			'text-image',
			'text-field',
			'text-font',
			'text-size',
			'text-justify',
			'text-anchor',
			'text-offset',
		]

		static paint = [
			'text-color',
			'text-opacity',
			'text-halo-color',
			'text-halo-width',
		]
	/*
		constructor(...args) {
			super(...args)
			var data = this.sourceOptions.data
			if (data.geometry.type === 'LineString') {
				let line = data
				let length = turf.length(line)
				this.sourceOptions.data = turf.along(line, length / 2)
			}
		}
	*/
		_wrapInGeoJson(arg) {
			if (isCoord(arg)) return turf.point(arg)
			if (isCoords(arg)) {
				var line = turf.lineString(arg);
				var length = turf.length(line);
				return turf.along(line, length / 2)
			}
			console.warn('unknown label data');
		}

		_createOptionsFromArgs(text, color, size) {
			return {text, color, size}
		}

		layerOptions = {
			minzoom: 3,
		}

		layout = {
			'text-size': 12,
		}

		paint = {
			'text-color': '#000',
			//'text-halo-color': '#EEE',
			//'text-halo-width': 5
		}

	}

	createGetters(Label);

	function getNewNode(size, color) {
		var node = document.createElement('div');
		Object.assign(node.style, {
			backgroundColor: color,
			width:  `${size}px`,
			height: `${size}px`,
			borderRadius: '100%',
			transitionDuration: '180ms',
			transitionTimingFunction: 'cubic-bezier(0.4, 0, 0.2, 1)',
			transitionProperty: 'transform, background, width, height',
			willChange: 'transform, background, width, height',
		});
		return node
	}


	class MapExtension$2 {

		render(data, ...args) {
			if (Array.isArray(data)) {
				if (isCoord(data)) {
					return this.renderPoint(data, ...args)
				} else if (isCoords(data)) {
					return this.renderLine(data, ...args)
				} else if (isBbox(data)) {
					return this.renderPolygon(data, ...args)
				}
			} else if (isGeoJson(data)) {
				if (data.type === 'Feature') {
					switch (data.geometry.type) {
						case 'Point':      return this.renderPoint(data, ...args)
						case 'LineString': return this.renderLine(data, ...args)
						case 'Polygon':    return this.renderPolygon(data, ...args)
					}
				}
				return this.renderGeoJson(data, ...args)
			} else if (typeof data === 'string' || typeof data === 'number') {
				this.renderLabel(data, ...args);
			} else {
				console.warn('unknown data to render', data);
			}
		}
		

		renderLine(...args) {
			return (new Line(args)).addTo(this)
		}
		
		renderPoint(...args) {
			return (new Point(args)).addTo(this)
		}

		renderLabel(...args) {
			return (new Label(args)).addTo(this)
		}

		renderPolygon(...args) {
			return (new Polygon(args)).addTo(this)
		}

		renderMarker(...args) {
			var node = args[0] instanceof HTMLElement ? args.shift() : undefined;
			var [coords, color, size] = args;
			if (!node) {
				if (size === undefined) size = 10;
				node = getNewNode(size, color);
			}
			return new mapboxgl.Marker(node)
				.setLngLat(turf.getCoord(coords))
				.addTo(this)
		}

		renderImage(url, coords, size, color) {
			var node = getNewNode(size, color);
			Object.assign(node.style, {
				backgroundPosition: 'center',
				backgroundSize: 'cover',
				backgroundImage: `url(${url})`
			});
			var container = document.createElement('div');
			container.appendChild(node);
			return new mapboxgl.Marker(container)
				.setLngLat(turf.getCoord(coords))
				.addTo(this)
		}

		/*
		renderBbox(bbox, color) {
			var slice = turf.lineSlice(this.startPoint.data, this.endPoint.data, this.line.data)
			var bbox = turf.bbox(slice)
			this.map.renderPolygon(bbox, this.section.color)
		}
		*/

	}

	extend(mapboxgl.Map, MapExtension$2);

	// inspired by https://github.com/mapbox/mapbox-gl-js/blob/f705fd2a4ddd8a33a13c6af048212d0f697d5c59/src/ui/handler/dblclick_zoom.js

	class DragTiltHandler {

		constructor(map) {
			this.map = map;
		}

		isEnabled() {
			return this._enabled
		}

		enable() {
			if (this.isEnabled()) return
			this._enabled = true;
			this.map.on('touchstart', this.onTouchStart);
			this.map.on('touchmove', this.onTouchMove);
			this.map.on('touchend', this.onTouchEnd);
			this.map.on('touchcancel', this.onTouchEnd);
		}

		disable() {
			if (!this.isEnabled()) return
			this._enabled = false;
			this.map.off('touchstart', this.onTouchStart);
			this.map.off('touchmove', this.onTouchMove);
			this.map.off('touchend', this.onTouchEnd);
			this.map.off('touchcancel', this.onTouchEnd);
		}

		onTouchStart = e => {
			if (e.points.length !== 2) return
			const diffY = Math.abs(e.points[0].y - e.points[1].y);
			const diffX = Math.abs(e.points[0].x - e.points[1].x);
			if (diffY > 40) return
			if (diffX > 120) return
			// prevent browser refresh on pull down
			e.originalEvent.preventDefault();
			// disable native touch controls
			this.touchZoomRotateWasEnabled = this.map.touchZoomRotate.isEnabled();
			this.dragPanWasEnabled = this.map.dragPan.isEnabled();
			if (this.touchZoomRotateWasEnabled)
				this.map.touchZoomRotate.disable();
			if (this.dragPanWasEnabled)
				this.map.dragPan.disable();
			this.point = e.point;
			this.pitch = this.map.getPitch();
		}

		onTouchMove = e => {
			if (!this.point) return
			e.preventDefault();
			e.originalEvent.preventDefault();
			var diff = (this.point.y - e.point.y) * 0.5;
			this.map.setPitch(this.pitch + diff);
		}

		onTouchEnd = e => {
			if (!this.point) return
			if (this.touchZoomRotateWasEnabled)
				this.map.touchZoomRotate.enable();
			if (this.dragPanWasEnabled)
				this.map.dragPan.enable();
			this.point = undefined;
		}

	}

	function init(map) {
		map.dragTilt = new DragTiltHandler(map);
		map.dragTilt.enable();
	}

	var {Map: Map$1} = mapboxgl;

	// needed to get hold of map instance, without having to do some nasty get/set Object.defineProperty hacks.
	// Maybe will be implemented in the future. Not enough time for now.
	Map$1.prototype.initToolbox = function() {
		init(this);
		//initZoomGesture(this)
	};
	console.log('toolbox index');

	exports.DASHED = DASHED;
	exports.DOTTED = DOTTED;
	exports.EventEmitter = EventEmitter;
	exports.Label = Label;
	exports.Line = Line;
	exports.Map = Map$1;
	exports.Point = Point;
	exports.Polygon = Polygon;
	exports.SOLID = SOLID;
	exports.createGetters = createGetters;
	exports.createRandomId = createRandomId;
	exports.extend = extend;
	exports.featuresMap = featuresMap;
	exports.getStyle = getStyle;
	exports.isBbox = isBbox;
	exports.isCoord = isCoord;
	exports.isCoords = isCoords;
	exports.isGeoJson = isGeoJson;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
